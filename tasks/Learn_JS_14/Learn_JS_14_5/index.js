// побитовые операторы интерпретируют операны как последовательность 32 битов (нулей и единиц)

// производят операцию и возвращают новую последовательность 32 битов

// они работают с целыми числами в их двоичном представлении

// старший бит слева - научное название для обычного порядка записи цифр
// пример

let a;

a = 0; // 00000000000000000000000000000000
a = 1; // 00000000000000000000000000000001
a = 2; // 00000000000000000000000000000010
a = 3; // 00000000000000000000000000000011
a = 255; // 00000000000000000000000011111111

// каждое число состоит из 32-битов

// дополнение до двойки - название способа поддержки отрицательного
// двоичный вид отрицательного числа получается путём прибавлением всем битам 1

// нули изменяются на единицы, единицы на нули
// а к числу прибавляется 1
// получается тоже число, но со знаком минусом

// 314
// 00000000000000000000000100111010
// -314

// меняем 0 на 1 и 1 на 0
// 11111111111111111111111011000101

// и добавляем 1
// 11111111111111111111111011000101 + 1 = 11111111111111111111111011000110

// -314 = 11111111111111111111111011000110

// принцип дополнения до двойки делит все двоичные представления на 2 множества
// если левый крайний бит равен 0, то число положительное
// если 1, то отрицательный
// поэтому этот бит называется знаковым битом

// Побитовое И (AND)	                a & b	    Ставит 1 на бит результата, для которого соответствующие биты операндов равны 1.
// Побитовое ИЛИ (OR)	                a | b	    Ставит 1 на бит результата, для которого хотя бы один из соответствующих битов операндов равен 1.
// Побитовое исключающее ИЛИ (XOR)	  a ^ b	    Ставит 1 на бит результата, для которого только один из соответствующих битов операндов равен 1 (но не оба).
// Побитовое НЕ (NOT)	                ~a	      Заменяет каждый бит операнда на противоположный.
// Левый сдвиг	                      a << b	  Сдвигает двоичное представление a на b битов влево, добавляя справа нули.
// Правый сдвиг, переносящий знак	    a >> b	  Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты.
// Правый сдвиг с заполнением нулями	a >>> b	  Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты и добавляя нули слева.

// 9 (по осн. 10)
//   = 00000000000000000000000000001001 (по осн. 2)
// 14 (по осн. 10)
//   = 00000000000000000000000000001110 (по осн. 2)
//                    --------------------------------
// 14 & 9 (по осн. 10)
//   = 00000000000000000000000000001000 (по осн. 2)
//   = 8 (по осн. 10)

console.log(9 & 14); // 8

// 9 (по осн. 10)
//   = 00000000000000000000000000001001 (по осн. 2)
// 14 (по осн. 10)
//   = 00000000000000000000000000001110 (по осн. 2)
//                    --------------------------------
// 14 | 9 (по осн. 10)
//   = 00000000000000000000000000001111 (по осн. 2)
//   = 15 (по осн. 10)

console.log(9 | 14); // 15

// 9 (по осн. 10)
//   = 00000000000000000000000000001001 (по осн. 2)
// 14 (по осн. 10)
//   = 00000000000000000000000000001110 (по осн. 2)
//                    --------------------------------
// 14 ^ 9 (по осн. 10)
//   = 00000000000000000000000000000111 (по осн. 2)
//   = 7 (по осн. 10)

console.log(9 ^ 14); // 7

// XOR можно использовать в шифровании, т.к. операция полностью обратима

// a ^ b ^ b == a
console.log((9 ^ 14 ^ 14) == 9); // true

// Пусть Вася хочет передать Пете секретную информацию data.
// Эта информация заранее превращена в число, например строка интерпретируется
// как последовательность кодов символов.

// Вася и Петя заранее договариваются о числовом ключе шифрования key.

// Алгоритм:

// Вася берёт двоичное представление data и делает операцию data ^ key.
// При необходимости data бьётся на части, равные по длине key,
// чтобы можно было провести побитовое ИЛИ ^ для каждой части.
// В JavaScript оператор ^ работает с 32 - битными целыми числами,
// так что data нужно разбить на последовательность таких чисел.

// Результат data ^ key отправляется Пете, это шифровка.

// дано 9 в двоичной системе
// 00000000000000000000000000001001
// есть ключ 1220461917
// 01001000101111101100010101011101

console.log(9 ^ 1220461917); // 1220461908 число шифровки

// отправляем это число и хотим расшифровать его

// Конечно, такое шифрование поддаётся частотному анализу и другим методам дешифровки,
// поэтому современные алгоритмы используют операцию XOR ^ как одну из
// важных частей более сложной многоступенчатой схемы.
console.log(1220461908 ^ 1220461917); // 9

// побитовое НЕ
//  9 (по осн. 10)
//   = 00000000000000000000000000001001 (по осн. 2)
//                --------------------------------
// ~9 (по осн. 10)
//   = 11111111111111111111111111110110 (по осн. 2)
//   = -10 (по осн. 10)
console.log(~9); // -10
console.log(~100); // -101
// из-за внутреннего представления получается -(n+1)

// 9 << 2
// Операторы битового сдвига принимают два операнда.
// Первый – это число для сдвига, а второй – количество битов, которые нужно сдвинуть в первом операнде.
// Оператор << сдвигает первый операнд на указанное число битов влево.
// Лишние биты отбрасываются, справа добавляются нулевые биты

// 9 (по осн.10)
//   = 00000000000000000000000000001001 (по осн.2)
//                   --------------------------------
// 2 = 10
// 9 << 2 (по осн.10)
//   = 00000000000000000000000000100100 (по осн.2)
//   = 36 (по осн.10)

console.log(9 << 2); // 36

// Битовый сдвиг << N обычно имеет тот же эффект, что и умножение на два N раз, например:
console.log(3 << 1); // 6, умножение на 2
console.log(3 << 2); // 12, умножение на 2 два раза
console.log(3 << 3); // 24, умножение на 2 три раза

// Конечно, следует иметь в виду, что побитовые операторы работают только с 32 - битными числами,
// поэтому верхний порог такого «умножения» ограничен:

console.log((10000000000).toString(2));
console.log(10000000000 << 1); // -1474836480, отброшен крайний-левый бит
console.log(10000000000 * 2); // 20000000000, обычное умножение

// >>
// Этот оператор сдвигает биты вправо, отбрасывая лишние. При этом слева добавляется копия крайнего-левого бита.

// Знак числа(представленный крайним - левым битом) при этом не меняется,
// так как новый крайний - левый бит имеет то же значение, что и в исходном числе.
// Поэтому он назван «переносящим знак».

console.log(9 >> 2); // 2

// 9 (по осн.10)
//   = 00000000000000000000000000001001 (по осн.2)
//                   --------------------------------
// 9 >> 2 (по осн.10)
//   = 00000000000000000000000000000010 (по осн.2)
//   = 2 (по осн.10)

console.log(-9 >> 2); // -3

// Правый сдвиг почти равен целочисленному делению на 2
// Битовый сдвиг >> N обычно имеет тот же результат, что и целочисленное деление на два N раз:
console.log(100 >> 1); // 50 деление на 2
console.log(100 >> 2); // 25 деление на 2 два раза

// >>>
// Этот оператор сдвигает биты первого операнда вправо.
// Лишние биты справа отбрасываются. Слева добавляются нулевые биты.

// Знаковый бит становится равным 0, поэтому результат всегда положителен.

// Для неотрицательных чисел правый сдвиг с заполнением нулями >>>
// и правый сдвиг с переносом знака >> дадут одинаковый результат, т.к.в обоих случаях слева добавятся нули.

// -9 (по осн.10)
//   = 11111111111111111111111111110111 (по осн.2)
//                     --------------------------------
// -9 >>> 2 (по осн.10)
//   = 00111111111111111111111111111101 (по осн.2)
//   = 1073741821 (по осн.10)

console.log(-9 >>> 2); // 1073741821

// Побитовые операторы используются редко, но всё же используются.

// В JavaScript побитовые операторы ^, &, | выполняются после сравнений ==.

// Например, в сравнении a == b ^ 0 будет сначала выполнено сравнение a == b,
// а потом уже операция ^ 0, как будто стоят скобки(a == b) ^ 0.

// Обычно это не то, чего мы хотим. Чтобы гарантировать желаемый порядок, нужно ставить скобки: a == (b^0).

// представим что наш скрипт работает с пользователями

// разные роли: Гость, редактор, админ

// Пользователь	Просмотр статей	Изменение статей	Просмотр товаров	Изменение товаров	Управление правами
// Гость	      Да	            Нет	              Да	              Нет	              Нет
// Редактор	    Да	            Да	              Да	              Да	              Нет
// Админ	      Да	            Да	              Да	              Да	              Да

// Если вместо «Да» поставить 1, а вместо «Нет» – 0, то каждый набор доступов описывается числом:

// Гость: 20
// Редактор: 30
// Админ: 31

// Такая интерпретация доступов позволяет «упаковать» много информации в одно число.
// Это экономит память, а кроме этого – это удобно, поскольку в дополнение к экономии – по такому значению очень легко проверить,
// имеет ли посетитель заданную комбинацию доступов!

// Для этого посмотрим, как в 2-ной системе представляется каждый доступ в отдельности.

// Доступ, соответствующий только управлению правами: 00001 (=1) (все нули кроме 1 на позиции, соответствующей этому доступу).
// Доступ, соответствующий только изменению товаров: 00010 (=2).
// Доступ, соответствующий только просмотру товаров: 00100 (=4).
// Доступ, соответствующий только изменению статей: 01000 (=8).
// Доступ, соответствующий только просмотру статей: 10000 (=16).

// Доступ одновременно на просмотр и изменение статей – это двоичное число с 1 на соответствующих позициях, то есть access = 11000.

// Как правило, доступы задаются в виде констант:

const ACCESS_ADMIN = 1; // 00001
const ACCESS_GOODS_EDIT = 2; // 00010
const ACCESS_GOODS_VIEW = 4; // 00100
const ACCESS_ARTICLE_EDIT = 8; // 01000
const ACCESS_ARTICLE_VIEW = 16; // 10000

// Из этих констант получить нужную комбинацию доступов можно при помощи операции |.

const guest = ACCESS_ARTICLE_VIEW | ACCESS_GOODS_VIEW; // 10100
const editor = guest | ACCESS_ARTICLE_EDIT | ACCESS_GOODS_EDIT; // 11110
const admin = editor | ACCESS_ADMIN; // 11111

// Теперь, чтобы понять, есть ли в доступе editor нужный доступ,
// например управление правами – достаточно применить к нему побитовый оператор И(&) с соответствующей константой.

// Ненулевой результат будет означать, что доступ есть:

console.log(editor & ACCESS_ADMIN); // 0 нет доступа
console.log(editor & ACCESS_ARTICLE_EDIT); // 8 есть доступ

const check = ACCESS_GOODS_VIEW | ACCESS_GOODS_EDIT;
console.log(check & admin); // 6, значит есть эти права

// битовой маской называют как раз комбинацию двоичных значений (check в примере выше)
// которая используется для проверки и выборки единиц на нужные позиции

// используются ещё чтобы передать несколько флагов, т.е. однобитных значений

// findUsers(ACCESS_GOODS_EDIT | ACCESS_ADMIN);

// Это довольно - таки коротко и элегантно, но, вместе с тем, применение масок налагает определённые ограничения.
//  В частности, побитовые операторы в JavaScript работают только с 32 - битными числами, а значит,
//   к примеру, 33 доступа уже в число не упакуешь.Да и работа с двоичной системой счисления – как ни крути,
//     менее удобна, чем с десятичной или с обычными логическими значениями true / false.

// Поэтому основная сфера применения масок – это быстрые вычисления, экономия памяти, низкоуровневые операции,
//   связанные с рисованием из JavaScript(3d - графика), интеграция с некоторыми функциями ОС(для серверного JavaScript),
//     и другие ситуации, когда уже существуют функции, требующие битовую маску.

// Так как битовые операции отбрасывают десятичную часть, то их можно использовать для округления.
// Достаточно взять любую операцию, которая не меняет значение числа.

console.log(~~12.345); // 12
console.log(12.345 ^ 0); // 12
console.log((1.1 + 0.3) ^ 0); // 1

// Обращение битов – это побитовое НЕ (~).
// То есть, при таком формате представления числа - n = ~n + 1. Или, если перенести единицу: ~n = -(n + 1).

// Как видно из последнего равенства, ~n == 0 только если n == -1. Поэтому можно легко проверить равенство n == -1:

let str = 'Проверка';

if (~str.indexOf('верка')) {
  // Сочетание "if (~...indexOf)" читается как "если найдено"
  console.log('найдено!');
}
