// Политика «Одинакового источника» (Same Origin) ограничивает доступ окон и фреймов друг к другу.

// Идея заключается в том, что если у пользователя открыто две страницы: john-smith.com и gmail.com,
//  то у скрипта со страницы john - smith.com не будет возможности прочитать письма из gmail.com

// Политика "Одинакового источника"
// Два URL имеют «одинаковый источник» в том случае, если они имеют совпадающие протокол, домен и порт.

// Эти URL имеют одинаковый источник:
// http://site.com
// http://site.com/
// http://site.com/my/page.html

// А эти – разные источники:
// http://www.site.com (другой домен: www. важен)
// http://site.org (другой домен: .org важен)
// https://site.com (другой протокол: https)
// http://site.com:8080 (другой порт: 8080)

// Политика «Одинакового источника» говорит, что:

// если у нас есть ссылка на другой объект window, например, на всплывающее окно, созданное с помощью window.open
//  или на window из < iframe > и у этого окна тот же источник, то к нему будет полный доступ.

// в противном случае, если у него другой источник, мы не сможем обращаться к его переменным, объекту document и так далее.
//  Единственное исключение – объект location: его можно изменять(таким образом перенаправляя пользователя).
// Но нельзя читать location(нельзя узнать, где находится пользователь, чтобы не было никаких утечек информации).

window.onclick = () => {
  const newWindow = window.open('https://gmail.com', 'gmail', 'width=500,height=500');
  console.log(newWindow); // есть location
  newWindow.onload = () => {
    // Uncaught DOMException: Blocked a frame with origin "http://127.0.0.1:5500" from accessing a cross-origin frame.
    // at window.onclick (http://127.0.0.1:5500/task3/Learn_JS_1/Learn_JS_1_2/index.js:31:20)
    console.log(newWindow);
  };
};

// Внутри <iframe> находится по сути отдельное окно с собственными объектами document и window.

// Мы можем обращаться к ним, используя свойства:

// iframe.contentWindow ссылка на объект window внутри <iframe>.
// iframe.contentDocument – ссылка на объект document внутри <iframe>, короткая запись для iframe.contentWindow.document.

// Когда мы обращаемся к встроенному в ифрейм окну, браузер проверяет, имеет ли ифрейм тот же источник.
// Если это не так, тогда доступ будет запрещён(разрешена лишь запись в location, это исключение)

// если у ифрейма тот же источник, то с ним можно делать всё, что угодно

// По определению, если у двух URL разный домен, то у них разный источник.
// Но если в окнах открыты страницы с поддоменов одного домена 2-го уровня, например john.site.com, peter.site.com и site.com
// (так что их общий домен site.com), то можно заставить браузер игнорировать это отличие

// Для этого в каждом таком окне нужно запустить:
// После этого они смогут взаимодействовать без ограничений.
// Ещё раз заметим, что это доступно только для страниц с одинаковым доменом второго уровня.

// Когда ифрейм – с того же источника, мы имеем доступ к документу в нём. Но есть подвох.
// Не связанный с кросс - доменными особенностями, но достаточно важный, чтобы о нём знать.

// Когда ифрейм создан, в нём сразу есть документ. Но этот документ – другой, не тот, который в него будет загружен!

// Так что если мы тут же сделаем что-то с этим документом, то наши изменения, скорее всего, пропадут.

let oldDoc = iframe.contentDocument;
iframe.onload = function () {
  let newDoc = iframe.contentDocument;
  // загруженный document - не тот, который был в iframe при создании изначально!
  console.log(oldDoc == newDoc); // false
};

// Нам не следует работать с документом ещё не загруженного ифрейма, так как это не тот документ.
// Если мы поставим на него обработчики событий – они будут проигнорированы.

// Можно проверять через setInterval:

oldDoc = iframe.contentDocument;

// каждый 100 мс проверяем, не изменился ли документ
let timer = setInterval(() => {
  let newDoc = iframe.contentDocument;
  if (newDoc == oldDoc) return;

  console.log('New document is here!');

  clearInterval(timer); // отключим setInterval, он нам больше не нужен
}, 100);

// Другой способ получить объект window из <iframe> – забрать его из именованной коллекции window.frames:
// По номеру: window.frames[0] – объект window для первого фрейма в документе.
// По имени: window.frames.iframeName – объект window для фрейма со свойством name="iframeName".

// Ифрейм может иметь другие ифреймы внутри. Таким образом, объекты window создают иерархию.

// Навигация по ним выглядит так:

// window.frames – коллекция «дочерних» window (для вложенных фреймов).
// window.parent – ссылка на «родительский» (внешний) window.
// window.top – ссылка на самого верхнего родителя.

console.log(window.parent); // мой window
console.log(window.top); // мой window

// Атрибут ифрейма sandbox

// Атрибут sandbox позволяет наложить ограничения на действия внутри <iframe>, чтобы предотвратить выполнение ненадёжного кода
// Атрибут помещает ифрейм в «песочницу», отмечая его как имеющий другой источник и/или накладывая на него дополнительные ограничения.

// Существует список «по умолчанию» ограничений, которые накладываются на <iframe sandbox src="...">
// Их можно уменьшить, если указать в атрибуте список исключений (специальными ключевыми словами),
// которые не нужно применять, например: <iframe sandbox="allow-forms allow-popups">.

// Другими словами, если у атрибута "sandbox" нет значения, то браузер применяет максимум ограничений,

// список ограничений:

// allow-same-origin
// "sandbox" принудительно устанавливает «другой источник» для ифрейма.
// Другими словами, он заставляет браузер воспринимать iframe, как пришедший из другого источника,
// даже если src содержит тот же сайт.Со всеми сопутствующими ограничениями для скриптов.Эта опция отключает это ограничение.

// allow-top-navigation
// Позволяет ифрейму менять parent.location.

// allow-forms
// Позволяет отправлять формы из ифрейма.

// allow-scripts
// Позволяет запускать скрипты из ифрейма.

// allow-popups
// Позволяет открывать всплывающие окна из ифрейма с помощью window.open.

// Это не все опции

// Атрибут "sandbox" создан только для того, чтобы добавлять ограничения. Он не может удалять их.
// В частности, он не может ослабить ограничения, накладываемые браузером на ифрейм, приходящий с другого источника.

// Интерфейс postMessage позволяет окнам общаться между собой независимо от их происхождения.
// Это способ обойти политику «Одинакового источника». Он позволяет обмениваться информацией, скажем john-smith.com и gmail.com,
//  но только в том случае, если оба сайта согласны и вызывают соответствующие JavaScript - функции.
// Это делает общение безопасным для пользователя.

// Интерфейс имеет две части.

// postMessage
// Окно, которое хочет отправить сообщение, должно вызвать метод postMessage окна получателя
// Другими словами, если мы хотим отправить сообщение в окно win, тогда нам следует вызвать
// win.postMessage(data, targetOrigin).

// Аргументы:

// data
// Данные для отправки. Может быть любым объектом, данные клонируются с использованием «алгоритма структурированного клонирования».
// IE поддерживает только строки, поэтому мы должны использовать метод JSON.stringify на сложных объектах, чтобы поддержать этот браузер.

// targetOrigin
// Определяет источник для окна-получателя, только окно с данного источника имеет право получить сообщение.
// Указание targetOrigin является мерой безопасности. Как мы помним, если окно (получатель) происходит из другого источника,
// мы из окна - отправителя не можем прочитать его location

// Если указать targetOrigin, то мы можем быть уверены, что окно получит данные только в том случае, если в нём правильный сайт.
//  Особенно это важно, если данные конфиденциальные.

// Например, здесь win получит сообщения только в том случае, если в нём открыт документ из источника http://example.com:

let win = window.frames.example;
win.postMessage('message', 'http://example.com');

// Если мы не хотим проверять, то в targetOrigin можно указать *.

win.postMessage('message', '*');

// Событие message

// Чтобы получать сообщения, окно-получатель должно иметь обработчик события message (сообщение).
// Оно срабатывает, когда был вызван метод postMessage(и проверка targetOrigin пройдена успешно).

// Объект события имеет специфичные свойства:

// data
// Данные из postMessage.

// origin
// Источник отправителя, например, http://javascript.info.

// source
// Ссылка на окно-отправитель. Можно сразу отправить что-то в ответ, вызвав source.postMessage(...).

// Чтобы добавить обработчик, следует использовать метод addEventListener, короткий синтаксис window.onmessage не работает.

window.addEventListener('message', function (e) {
  // неизвестный домен
  if (e.origin != 'http://javascript.info') return;
  console.log('received: ', e.data);
});

// Между postMessage и событием message не существует задержки. Событие происходит синхронно, быстрее, чем setTimeout(...,0).
