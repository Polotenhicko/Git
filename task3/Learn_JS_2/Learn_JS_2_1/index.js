// В сфере веб-разработки мы встречаемся с бинарными данными чаще всего тогда, когда требуется выполнить какие-то действия над файлами

// Всё это возможно осуществить на JavaScript. Более того, операции над бинарными данными являются высокопроизводительными.

// Обилие классов для работы с бинарными данными может немного запутать. Вот некоторые из них:
// ArrayBuffer, Uint8Array, DataView, Blob, File и т.д.

// Базовый объект для работы с бинарными данными имеет тип ArrayBuffer и представляет собой ссылку на непрерывную область
// памяти фиксированной длины.

let buffer = new ArrayBuffer(16); // буфер длиной 16
console.log(buffer.length); // undefined
console.log(buffer.byteLength); // 16

// ArrayBuffer – это не массив!
// Для доступа к отдельным байтам нужен вспомогательный объект-представление,
console.log(buffer[0]); // undefined

// Примеры интерпритаторов:

// Uint8Array
// представляет каждый байт в ArrayBuffer как отдельное число; возможные значения находятся в промежутке от 0 до 255
// «8-битное целое без знака»

// Uint16Array
// представляет каждые 2 байта в ArrayBuffer как целое число; возможные значения находятся в промежутке от 0 до 65535
// «16-битное целое без знака»

// Uint32Array
// представляет каждые 4 байта в ArrayBuffer как целое число; возможные значения находятся в промежутке от 0 до 4294967295
// «32-битное целое без знака»

// Float64Array
// представляет каждые 8 байт в ArrayBuffer как число с плавающей точкой; возможные значения находятся в промежутке между 5.0x10**-324 и 1.8x10**308.

// ArrayBuffer – это корневой объект, основа всего, необработанные бинарные данные.

// Но если мы собираемся что-то записать в него или пройтись по его содержимому,
// да и вообще для любых действий мы должны использовать какой - то объект - представление(«view»),

let view = new Uint32Array(buffer);

console.log(Uint32Array.BYTES_PER_ELEMENT); // 4 байта на элемент
console.log(view.length); // 4
console.log(view.byteLength); // 16

view[0] = 321321;
for (const num of view) {
  console.log(num); // 321321, потом 3 нуля
}

buffer = new ArrayBuffer(12);
view = new Uint32Array(buffer);
console.log(view.length); // 3

// Общий термин для всех таких представлений (Uint8Array, Uint32Array и т.д.) – это TypedArray,
// типизированный array

// Есть 5 вариантов создания типизированных массивов:
// new TypedArray(buffer, [byteOffset], [length]);
// new TypedArray(object);
// new TypedArray(typedArray);
// new TypedArray(length);
// new TypedArray();

// 1. Если передан аргумент типа ArrayBuffer, то создаётся объект-представление для него
// Дополнительно можно указать аргументы byteOffset (0 по умолчанию) и length (до конца буфера по умолчанию),
//  тогда представление будет покрывать только часть данных в buffer.

// 2. Если в качестве аргумента передан Array или какой-нибудь псевдомассив,
// то будет создан типизированный массив такой же длины и с тем же содержимым

let arr = new Uint8Array([0, 1, 2, 3]);
console.log(arr.length); // 4

// 3. Если в конструктор передан другой объект типа TypedArray, то делается то же самое:
// создаётся типизированный массив с такой же длиной и в него копируется содержимое

let arr16 = new Uint16Array([1, 1000]);
let arr8 = new Uint8Array(arr16);
console.log(arr8[0]); // 1
console.log(arr8[1]); // 232, потому что 1000 не помещается в 8 бит

// 4. Если передано число length – будет создан типизированный массив, содержащий именно столько элементов.
// Размер нового массива в байтах будет равен числу элементов length,
// умноженному на размер одного элемента TypedArray.BYTES_PER_ELEMENT:

arr = new Uint16Array(4); // создаём типизированный массив для 4 целых 16-битных чисел без знака
console.log(Uint16Array.BYTES_PER_ELEMENT); // 2 байта на число
console.log(arr.byteLength); // 8 (размер массива в байтах)

// 5. При вызове без аргументов будет создан пустой типизированный массив.

// Для доступа к ArrayBuffer в TypedArray есть следующие свойства:
// buffer – ссылка на объект ArrayBuffer.
// byteLength – размер содержимого ArrayBuffer в байтах.

// Таким образом, мы всегда можем перейти от одного представления к другому:
arr8 = new Uint8Array([0, 1, 2, 3]);

// другое представление на тех же данных
arr16 = new Uint16Array(arr8.buffer);

// Список типизированных массивов:

// Uint8Array, Uint16Array, Uint32Array – целые беззнаковые числа по 8, 16 и 32 бита соответственно.
//    Uint8ClampedArray – 8-битные беззнаковые целые, обрезаются по верхней и нижней границе при присвоении
// Int8Array, Int16Array, Int32Array – целые числа со знаком (могут быть отрицательными).
// Float32Array, Float64Array – 32- и 64-битные числа со знаком и плавающей точкой.

// Что если мы попытаемся записать в типизированный массив значение, которое превышает допустимое для данного массива?
// Лишние биты просто будут отброшены.

let uint8array = new Uint8Array(16);
let num = 256;
console.log(num.toString(2)); // 100000000

uint8array[0] = 256;
uint8array[1] = 257;

console.log(uint8array[0]); // 0
console.log(uint8array[1]); // 1

// Типизированные массивы TypedArray, за некоторыми заметными исключениями, имеют те же методы, что и массивы Array.
// Мы можем обходить их, вызывать map, slice, find, reduce и т.д.

// Однако, есть некоторые вещи, которые нельзя осуществить:

// 1. Нет метода splice – мы не можем удалять значения, потому что типизированные массивы – это всего лишь представления
// данных из буфера, а буфер – это непрерывная область памяти фиксированной длины

// 2. Нет метода concat.

// Но зато есть два дополнительных метода:

// arr.set(fromArr, [offset]) копирует все элементы из fromArr в arr, начиная с позиции offset (0 по умолчанию).
// arr.subarray([begin, end]) создаёт новое представление того же типа для данных, начиная с позиции begin до end (не включая)

// Эти методы позволяют нам копировать типизированные массивы, смешивать их, создавать новые на основе существующих и т.д.

// DataView
// DataView – это специальное супергибкое нетипизированное представление данных из ArrayBuffer
// Оно позволяет обращаться к данным на любой позиции и в любом формате.

// В случае типизированных массивов конструктор строго задаёт формат данных. Весь массив состоит из однотипных значений.
// Доступ к i - ому элементу можно получить как arr[i].

// В случае DataView доступ к данным осуществляется посредством методов типа .getUint8(i) или .getUint16(i).
// Мы выбираем формат данных в момент обращения к ним, а не в момент их создания.

// Синтаксис:
// new DataView(buffer, [byteOffset], [byteLength]);

// buffer – ссылка на бинарные данные ArrayBuffer
// byteOffset – начальная позиция данных для представления (по умолчанию 0).
// byteLength – длина данных (в байтах), используемых в представлении (по умолчанию – до конца buffer).

// Например, извлечём числа в разных форматах из одного и того же буфера двоичных данных:

buffer = new Uint8Array([255, 255, 255, 255]).buffer;
let dataView = new DataView(buffer);

// получим 8-битное число на позиции 0
console.log(dataView.getUint8(0)); // 255

// а сейчас мы получим 16-битное число на той же позиции 0, оно состоит из 2-х байт, вместе составляющих число 65535
// ?????
console.log(dataView.getUint16(0)); // 65535 (максимальное 16-битное беззнаковое целое)

// получим 32-битное число на позиции 0
console.log(dataView.getUint32(0));

dataView.setUint32(0, 0); // при установке 4-байтового числа в 0, во все его 4 байта будут записаны нули

// Представление DataView отлично подходит, когда мы храним данные разного формата в одном буфере.
