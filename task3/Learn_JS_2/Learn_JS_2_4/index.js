// Объект File наследуется от объекта Blob и обладает возможностями по взаимодействию с файловой системой.

// Есть два способа его получить.

// Во-первых, есть конструктор, похожий на Blob:
// new File(fileParts, fileName, [options])

// fileParts – массив значений Blob/BufferSource/строки.
// fileName – имя файла, строка.
// options – необязательный объект со свойством:
//  lastModified – дата последнего изменения в формате таймстамп (целое число).

// Во-вторых, чаще всего мы получаем файл из <input type="file"> или через перетаскивание с помощью мыши,
//  или из других интерфейсов браузера.В этом случае файл получает эту информацию из ОС.

// Так как File наследует от Blob, у объектов File есть те же свойства плюс:
// name – имя файла,
// lastModified – таймстамп для даты последнего изменения.

// В этом примере мы получаем объект File из <input type="file">:

file.onchange = (e) => {
  console.log(e.target.files); // массив файлов
  const file = e.target.files[0];

  console.log(file.name); // Безымянный.jpg
  console.log(file.lastModified); // 1676305305895
};

// раз files - массив, то значит можно выбрать много файлов

// FileReader
// FileReader объект, цель которого читать данные из Blob (и, следовательно, из File тоже).

// let reader = new FileReader(); // без аргументов

// Основные методы:

// readAsArrayBuffer(blob) – считать данные как ArrayBuffer
//  для бинарных файлов, для низкоуровневой побайтовой работы с бинарными данными
// readAsText(blob, [encoding]) – считать данные как строку (кодировка по умолчанию: utf-8)
//  для текстовых файлов, когда мы хотим получить строку
// readAsDataURL(blob) – считать данные как base64-кодированный URL.
//  когда мы хотим использовать данные в src для img или другого тега. Есть альтернатива – можно не читать файл, а вызвать URL.createObjectURL(file)
// abort() – отменить операцию.

// В процессе чтения происходят следующие события:

// loadstart – чтение начато.
// progress – срабатывает во время чтения данных.
// load – нет ошибок, чтение окончено.
// abort – вызван abort().
// error – произошла ошибка.
// loadend – чтение завершено (успешно или нет).

// Когда чтение закончено, мы сможем получить доступ к его результату следующим образом:

// reader.result результат чтения (если оно успешно)
// reader.error объект ошибки (при неудаче).

// Пример чтения файлов

file.onchange = (e) => {
  const file = e.target.files[0];
  const reader = new FileReader();

  reader.readAsText(file);

  reader.onload = () => console.log(reader.result);
  reader.onerror = () => console.error(reader.error);
};

// Для Web Worker также доступен FileReaderSync
// Он синхронный

// Его методы считывания read* не генерируют события, а возвращают результат, как это делают обычные функции.
