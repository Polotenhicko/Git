// Протокол WebSocket («веб-сокет»), описанный в спецификации RFC 6455, обеспечивает возможность обмена данными между браузером
//  и сервером через постоянное соединение

// WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.

// Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол ws:
// let socket = new WebSocket('ws://localhost:3000');
// Также существует протокол wss://, использующий шифрование. Это как HTTPS для веб-сокетов.

// Протокол wss:// не только использует шифрование, но и обладает повышенной надёжностью.
// Советуют его использовать
// Это потому, что данные ws:// не зашифрованы, видны для любого посредника.

// С другой стороны, wss:// – это WebSocket поверх TLS (так же, как HTTPS – это HTTP поверх TLS),
// безопасный транспортный уровень шифрует данные от отправителя и расшифровывает на стороне получателя.
// Пакеты данных передаются в зашифрованном виде через прокси, которые не могут видеть, что внутри, и всегда пропускают их.

// Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:

// open – соединение установлено,
// message – получены данные,
// error – ошибка,
// close – соединение закрыто.

// …А если мы хотим отправить что-нибудь, то вызов socket.send(data) сделает это.

socket = new WebSocket('wss://javascript.info/article/websocket/demo/hello');

socket.onopen = function (e) {
  console.log('[open] Соединение установлено');
  console.log('Отправляем данные на сервер');
  socket.send('Инфа');
};

socket.onmessage = function (e) {
  console.log(`Данные получены с сервера: ${e.data}`);
};

socket.onclose = function (e) {
  if (e.wasClean) {
    console.log(`Соединение закрыто чисто, код=${e.code} причина=${e.reason}`);
  } else {
    // например, сервер убил процесс или сеть недоступна
    // обычно в этом случае event.code 1006
    console.log('Соединение прервано');
  }
};

socket.onerror = function (e) {
  console.log('error');
};

// Он отвечает «Привет с сервера, Джон», после ожидает 5 секунд и закрывает соединение.
// open → message → close.

// Когда new WebSocket(url) создан, он тут же сам начинает устанавливать соединение.

// Браузер, при помощи специальных заголовков, спрашивает сервер: «Ты поддерживаешь Websocket?» и если сервер отвечает «да»,
// они начинают работать по протоколу WebSocket, который уже не является HTTP.

// Вот пример заголовков для запроса, который делает new WebSocket("wss://javascript.info/chat").
// GET /chat
// Host: javascript.info
// Origin: https://javascript.info
// Connection: Upgrade
// Upgrade: websocket
// Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
// Sec-WebSocket-Version: 13

// Connection: Upgrade – сигнализирует, что клиент хотел бы изменить протокол.
// Upgrade: websocket – запрошен протокол «websocket».
// Sec-WebSocket-Key – случайный ключ, созданный браузером для обеспечения безопасности.
// Sec-WebSocket-Version – версия протокола WebSocket, текущая версия 13.

// Запрос WebSocket нельзя эмулировать
// Мы не можем использовать XMLHttpRequest или fetch для создания такого HTTP-запроса, потому что JavaScript не позволяет устанавливать такие заголовки.

// Если сервер согласен переключиться на WebSocket, то он должен отправить в ответ код 101:
// 101 Switching Protocols
// Upgrade: websocket
// Connection: Upgrade
// Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=

// Здесь Sec-WebSocket-Accept – это Sec-WebSocket-Key, перекодированный с помощью специального алгоритма.
// Браузер использует его, чтобы убедиться, что ответ соответствует запросу.

// Могут быть дополнительные заголовки Sec-WebSocket-Extensions и Sec-WebSocket-Protocol, описывающие расширения и подпротоколы.

// Например:
// Sec-WebSocket-Extensions: deflate-frame означает, что браузер поддерживает сжатие данных.
// Расширение – это что-то, связанное с передачей данных, расширяющее сам протокол WebSocket.
// Заголовок Sec - WebSocket - Extensions отправляется браузером автоматически со списком всевозможных расширений,
// которые он поддерживает.

// Sec-WebSocket-Protocol: soap, wamp означает, что мы будем передавать не только произвольные данные,
// но и данные в протоколах SOAP или WAMP
// (The WebSocket Application Messaging Protocol" – «протокол обмена сообщениями WebSocket приложений»).
// То есть этот заголовок описывает не передачу, а формат данных, который мы собираемся использовать.
// Официальные подпротоколы WebSocket регистрируются в каталоге IANA.

// Этот необязательный заголовок ставим мы сами, передавая массив подпротоколов вторым параметром new WebSocket, вот так:
socket = new WebSocket('wss://javascript.info/chat', ['soap', 'wamp']);

// Сервер должен ответить перечнем протоколов и расширений, которые он может использовать.
// Например, запрос:
// GET /chat
// Host: javascript.info
// Upgrade: websocket
// Connection: Upgrade
// Origin: https://javascript.info
// Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
// Sec-WebSocket-Version: 13
// Sec-WebSocket-Extensions: deflate-frame
// Sec-WebSocket-Protocol: soap, wamp

// Ответ:

// 101 Switching Protocols
// Upgrade: websocket
// Connection: Upgrade
// Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=
// Sec-WebSocket-Extensions: deflate-frame
// Sec-WebSocket-Protocol: soap

// Здесь сервер отвечает, что поддерживает расширение – deflate-frame и может использовать только протокол
// SOAP из всего списка запрошенных подпротоколов.

// Передача самих данных
// Поток данных в WebSocket состоит из «фреймов», фрагментов данных, которые могут быть отправлены любой стороной,
// и которые могут быть следующих видов:

// «текстовые фреймы» – содержат текстовые данные, которые стороны отправляют друг другу.
// «бинарные фреймы» – содержат бинарные данные, которые стороны отправляют друг другу.
// «пинг-понг фреймы» используется для проверки соединения; отправляется с сервера, браузер реагирует на них автоматически.
// также есть «фрейм закрытия соединения» и некоторые другие служебные фреймы.

// В браузере мы напрямую работаем только с текстовыми и бинарными фреймами.

// Метод WebSocket .send() может отправлять и текстовые, и бинарные данные.
// Вызов socket.send(body) принимает body в виде строки или любом бинарном формате включая Blob, ArrayBuffer и другие

// При получении данных, текст всегда поступает в виде строки.
// А для бинарных данных мы можем выбрать один из двух форматов: Blob или ArrayBuffer.

// Это задаётся свойством socket.binaryType, по умолчанию оно равно "blob", так что бинарные данные поступают в виде Blob-объектов.
// Blob – это высокоуровневый бинарный объект, он напрямую интегрируется с <a>, <img> и другими тегами, так что это вполне удобное значение по умолчанию
// Но для обработки данных, если требуется доступ к отдельным байтам, мы можем изменить его на "arraybuffer":

socket.binaryType = 'blob';
socket.binaryType = 'arrayBuffer';
socket.onmessage = (event) => {
  // event.data является строкой (если текст) или arraybuffer (если двоичные данные)
};

// Ограничение скорости

// Представим, что наше приложение генерирует много данных для отправки. Но у пользователя медленное соединение,
// возможно, он в интернете с мобильного телефона и не из города.

// Мы можем вызывать socket.send(data) снова и снова. Но данные будут буферизованы (сохранены) в памяти и отправлены
// лишь с той скоростью, которую позволяет сеть.
// Мы можем изучить его, чтобы увидеть, действительно ли сокет доступен для передачи.
