// Если мы сделаем запрос fetch на другой веб-сайт, он, вероятно, завершится неудачей.

(async () => {
  try {
    await fetch('https://learn.javascript.ru/fetch-crossorigin');
  } catch (err) {
    console.error(err); // TypeError: Failed to fetch
  }
})();

// Ключевым понятием здесь является источник (origin) – комбинация домен/порт/протокол.
// Запросы на другой источник – отправленные на другой домен (или даже поддомен), или протокол,
// или порт – требуют специальных заголовков от удалённой стороны.

// Эта политика называется «CORS»: Cross-Origin Resource Sharing («совместное использование ресурсов между разными источниками»).

// CORS существует для защиты интернета от злых хакеров.

// Раньше
// Многие годы скрипт с одного сайта не мог получить доступ к содержимому другого сайта.

// Это простое, но могучее правило было основой интернет-безопасности. Например, хакерский скрипт с сайта hacker.com
// не мог получить доступ к почтовому ящику пользователя на сайте gmail.com.И люди чувствовали себя спокойно.

// Есть два вида запросов на другой источник:

// 1. Простые.
// 2. Все остальные.

// Простой запрос – это запрос, удовлетворяющий следующим условиям:
// 1. Простой метод: GET, POST или HEAD
// 2. Простые заголовки – разрешены только:
//    Accept,
//    Accept-Language,
//    Content-Language,
//    Content-Type со значением application/x-www-form-urlencoded, multipart/form-data или text/plain.

// то есть без application/json и blob
// и без Content-Length, хотя мб он автоматом ставится

// Любой другой запрос считается «непростым». Например, запрос с методом PUT или с HTTP-заголовком API-Key не соответствует условиям.
// хз как сделать из этих хоть какой-то HEAD
// Таким образом, даже очень старый сервер должен быть способен принять простой запрос.

// В противоположность этому, запросы с нестандартными заголовками или, например, методом DELETE нельзя создать таким способом

// Когда мы пытаемся сделать непростой запрос, браузер посылает специальный предварительный запрос
// («предзапрос», по англ. «preflight»), который спрашивает у сервера – согласен ли он принять такой непростой запрос или нет ?

// При запросе на другой источник браузер всегда ставит «от себя» заголовок Origin.
// Например, если мы запрашиваем https://anywhere.com/request со страницы https://javascript.info/page, заголовки будут такими:
// GET /request
// Host: anywhere.com
// Origin: https://javascript.info

// Origin содержит именно источник (домен/протокол/порт), без пути.

// Сервер может проверить Origin и, если он согласен принять такой запрос,
// добавить особый заголовок Access - Control - Allow - Origin к ответу.

// Этот заголовок должен содержать разрешённый источник (в нашем случае https://javascript.info) или звёздочку *.
// Тогда ответ успешен, в противном случае возникает ошибка.

// Здесь браузер играет роль доверенного посредника:

// 1. Он гарантирует, что к запросу на другой источник добавляется правильный заголовок Origin.
// 2. Он проверяет наличие разрешающего заголовка Access-Control-Allow-Origin в ответе и, если всё хорошо,
//    то JavaScript получает доступ к ответу сервера, в противном случае – доступ запрещается с ошибкой.

// Вот пример ответа сервера, который разрешает доступ:

// 200 OK
// Content-Type:text/html; charset=UTF-8
// Access-Control-Allow-Origin: https://javascript.info

// По умолчанию при запросе к другому источнику JavaScript может получить доступ только к так называемым «простым» заголовкам ответа:

// Cache-Control
// Content-Language
// Content-Length
// Content-Type
// Expires
// Last-Modified
// Pragma

// При попытке доступа к другим заголовкам - будет ошибка

// Чтобы разрешить JavaScript доступ к любому другому заголовку ответа, сервер должен указать заголовок
// Access-Control-Expose-Headers
// Он содержит список, через запятую, заголовков, которые не являются простыми, но доступ к которым разрешён.

// 200 OK
// Content-Type:text/html; charset=UTF-8
// Content-Length: 12345
// Content-Encoding: gzip
// API-Key: 2c9de507f2c54aa1
// Access-Control-Allow-Origin: https://javascript.info
// Access-Control-Expose-Headers: Content-Encoding,API-Key

// При таком заголовке Access-Control-Expose-Headers, скрипту разрешено получить заголовки Content-Encoding и API-Key ответа.

// Предварительный запрос использует метод OPTIONS, у него нет тела, но есть три заголовка:

// Origin содержит именно источник (домен/протокол/порт), без пути.
// Access-Control-Request-Method содержит HTTP-метод «непростого» запроса.
// Access-Control-Request-Headers предоставляет разделённый запятыми список его «непростых» HTTP-заголовков.

// Если сервер согласен принимать такие запросы, то он должен ответить без тела, со статусом 200 и с заголовками:

// Access-Control-Allow-Origin должен содержать разрешённый источник.
// Access-Control-Allow-Methods должен содержать разрешённые методы.
// Access-Control-Allow-Headers должен содержать список разрешённых заголовков.
// Access-Control-Max-Age может указывать количество секунд, на которое нужно кешировать разрешения.
//  Так что браузеру не придётся посылать предзапрос для последующих запросов, удовлетворяющих данным разрешениям.

// Пример с patch

(async () => {
  const response = await fetch('https://site.com/service.json', {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json',
      'API-Key': 'secret',
    },
  });
})();

// Этот запрос не является простым по трём причинам (достаточно одной):

// Метод PATCH
// Content-Type не один из: application/x-www-form-urlencoded, multipart/form-data, text/plain.
// Содержит «непростой» заголовок API-Key.

// будет ошибка

// Шаг 1 (предзапрос)
// Перед тем, как послать такой запрос, браузер самостоятельно генерирует и посылает предзапрос, который выглядит следующим образом:

// OPTIONS /service.json
// Host: site.com
// Origin: localhost:3000
// Access-Control-Request-Method: PATCH
// Access-Control-Request-Headers: Content-Type,API-Key

// Метод: OPTIONS.
// Путь – точно такой же, как в основном запросе: /service.json.
// Особые заголовки:
// Origin – источник.
// Access-Control-Request-Method – запрашиваемый метод.
// Access-Control-Request-Headers – разделённый запятыми список «непростых» заголовков запроса.

// Шаг 2 (ответ сервера на предзапрос)
// Сервер должен ответить со статусом 200 и заголовками:

// Access-Control-Allow-Methods: PATCH
// Access-Control-Allow-Headers: Content-Type,API-Key.

// иначе будет ошибка

// Теперь, когда браузер видит, что PATCH есть в Access-Control-Allow-Methods, а Content-Type,API-Key –
// в списке Access - Control - Allow - Headers, он посылает наш основной запрос.

// Шаг 3 (основной запрос)

// Если предзапрос успешен, браузер делает основной запрос. Алгоритм здесь такой же, что и для простых запросов.

// Основной запрос имеет заголовок Origin (потому что он идёт на другой источник):

// PATCH /service.json
// Host: site.com
// Content-Type: application/json
// API-Key: secret
// Origin: https://javascript.info

// Сервер не должен забывать о добавлении Access-Control-Allow-Origin к ответу на основной запрос.

// Access-Control-Allow-Origin: https://javascript.info

// После этого JavaScript может прочитать ответ сервера.

// Запрос на другой источник по умолчанию не содержит авторизационных данных (credentials),
// под которыми здесь понимаются куки и заголовки HTTP - аутентификации.

// Это нетипично для HTTP-запросов. Обычно запрос к http://site.com сопровождается всеми куки с этого домена.
// Но запросы на другой источник, сделанные методами JavaScript – исключение.

// Например, fetch('http://another.com') не посылает никаких куки, даже тех (!), которые принадлежат домену another.com.

// Потому что запрос с авторизационными данными даёт намного больше возможностей, чем без них.
// Если он разрешён, то это позволяет JavaScript действовать от имени пользователя и получать информацию,
// используя его авторизационные данные.

// Чтобы включить отправку авторизационных данных в fetch, нам нужно добавить опцию credentials: "include", вот так:
fetch('http://another.com', {
  credentials: 'include',
});

// А почему мы то должны включать их? Непонел

// Теперь fetch пошлёт куки с домена another.com вместе с нашим запросом на этот сайт.

// Если сервер согласен принять запрос с авторизационными данными, он должен добавить заголовок
// Access-Control-Allow-Credentials: true к ответу, в дополнение к Access-Control-Allow-Origin.

// !!!!
// Access-Control-Allow-Origin запрещено использовать звёздочку * для запросов с авторизационными данными
// Там должен быть именно источник
//  Это дополнительная мера безопасности, чтобы гарантировать, что сервер действительно знает, кому он доверяет делать такие запросы.
