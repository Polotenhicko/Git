// куки
document.cookie = '';
// куки небольшие строки данных, которые хранятся непосредственно в браузере
// являются частью http-протокола

// устанавливаются обычно веб-сервером при помощи заголовка Set-Cookie.
// затем браузер будет автоматически добавлять их почти в каждый запрос
// на тот же домен при помощи заголовка Cookie

// Самый частый способ использования куки - аутентификация:
// 1. При входе на сайт сервер отсылает в ответ HTTP-заголовок Set-Cookie чтобы установить куки
//    со спец уникальным индетификатором сессии (session identifier)
// 2. Во время след запроса к этому же домену браузер посылает на сервер http заголовок Cookie
// 3. Таким образом, сервер понимает, кто сделал запрос

console.log(document.cookie); // у меня пустая строка, но обычно просто строка
// Значение document.cookie состоит из пар ключ=значение, разделённых ;. Каждая пара представляет собой отдельное куки.

// Запись в document.cookie
// Мы можем писать в document.cookie. Но это не просто свойство данных, а акcессор (геттер/сеттер).
// Присваивание к нему обрабатывается особым образом.

// Запись в document.cookie обновит только упомянутые в ней куки, но при этом не затронет все остальные.

// обновляем только куки с именем user и значением John
// в данном случае я установлю такой куки
document.cookie = 'user=John';
document.cookie = 'email=zopa@mail.ru';
console.log(document.cookie); // "user=John; email=zopa@mail.ru"

// Технически, и имя и значение куки могут состоять из любых символов, для правильного форматирования следует
// использовать встроенную функцию encodeURIComponent:

const name = 'my name';
const value = 'John Smith';
document.cookie = name + '=' + value;
console.log(document.cookie);

// работает, но лучше форматировать

document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);
console.log(document.cookie); // my%20name=John%20Smith

// Есть ограничения:
// 1. Пара name=value не должна занимать более 4Кб, а encodeURIComponent увеличивает объём
// 2. Общее количество куки на один домен ограничивается примерно 20+. Точное ограничение зависит от конкретного браузера.

// ещё есть настройки
// указываются после пары ключ=значение и отделены друг от друга ;

document.cookie = 'user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT';

// path
// path=/mypath

// URL-префикс пути, куки будут доступны для страниц под этим путём. Должен быть абсолютным. По умолчанию используется текущий путь.
// Если куки установлено с path=/admin, то оно будет доступно на страницах /admin и /admin/something, но не на страницах /home или /adminpage.

// Как правило, указывают в качестве пути корень path=/, чтобы наше куки было доступно на всех страницах сайта.

// domain
// domain=site.com

// Домен определяет, где доступен файл куки
// Нет никакого способа разрешить доступ к файлам куки из другого домена 2-го уровня, поэтому other.com никогда не получит куки,
// установленный по адресу site.com.
// Это и логично

// По умолчанию куки доступны лишь тому домену, который его установил.
// по умолчанию файл куки также не передаётся поддомену, например forum.site.com.

// если мы установим файл куки на веб-сайте site.com...
document.cookie = 'user=John';

// ...мы не увидим его на forum.site.com
console.log(document.cookie); // нет user

// Но это можно изменить.
// Если мы хотим разрешить поддоменам типа forum.site.com получать куки, установленные на site.com, это возможно.

// Чтобы это произошло, при установке файла куки в site.com, мы должны явно установить параметр domain для корневого домена:
// domain=site.com. После этого все поддомены увидят такой файл cookie.

document.cookie = 'user=John; domain=site.com';
// на forum.site.com
document.cookie; // есть куки user=John

// expires, max-age
// По умолчанию, если куки не имеют ни одного из этих параметров, то они удалятся при закрытии браузера.
// Такие куки называются сессионными(«session cookies»).

// Чтобы помочь куки «пережить» закрытие браузера, мы можем установить значение опций expires или max-age.
// expires=Tue, 19 Jan 2038 03:14:07 GMT
// Дата истечения срока действия куки, когда браузер удалит его автоматически.

// Используется время по GMT
// это можно делать через объект даты
const date = new Date(Date.now() + 1000 * 60).toUTCString();

// если установить прошедшую дату, то куки будет удалено
document.cookie = 'time=aaa; expires=' + date;

// max-age=3600
// альтернатива expires, определяет срок действия куки с текущего момента
// в секундах

document.cookie = 'time=aaa; max-age=3600';

// secure
// Куки следует передавать только по HTTPS-протоколу.

// По умолчанию куки, установленные сайтом http://site.com, также будут доступны на сайте https://site.com и наоборот.
// Но если поставить secure, то куки не будет доступна на http протоколе

// Таким образом, если в куки хранится конфиденциальная информация, которую не следует передавать по незашифрованному протоколу HTTP,
// то нужно установить этот флаг.

// samesite
// Устанавливается для защиты от XCRF-атаки

// Атака XSRF или CSRF:
// На сайте злоумышленника будет отправка запроса на сайт с авторизационными куками пользователя
// По сути можно и без пользователя это осуществить

// Настройка samesite
// Параметр куки samesite предоставляет ещё один способ защиты от таких атак, который (теоретически) не должен требовать «токенов защиты xsrf».

// У него есть два возможных значения:

// samesite=strict (или, что то же самое, samesite без значения)
// Куки с samesite=strict никогда не отправятся, если пользователь пришёл не с этого же сайта.

// Другими словами, если пользователь переходит по ссылке из почты, отправляет форму с evil.com или выполняет любую другую операцию,
// происходящую с другого домена, то куки не отправляется.
// А вот тут максимально не понятно стало
// Вроде ставим эту настройку для куки на сайте bank.com, как это может относиться к evil.com?

// Хотя есть небольшие неудобства.
// Когда пользователь перейдёт по ссылке на bank.com, например из своих заметок, он будет удивлён, что сайт bank.com не узнал его.
// Действительно, куки с samesite = strict в этом случае не отправляется.

// Мы могли бы обойти это ограничение, используя два куки: одно куки для «общего узнавания», только для того, чтобы поздороваться:
// «Привет, Джон», и другое куки для операций изменения данных с samesite = strict.
// Тогда пользователь, пришедший на сайт, увидит приветствие, но платежи нужно инициировать с сайта банка,
// чтобы отправилось второе куки.

// samesite=lax
// Более мягкий вариант

// Куки с samesite=lax отправляется, если два этих условия верны:

// 1. Используются безопасные HTTP-методы (например, GET, но не POST).
// Полный список безопасных HTTP-методов можно посмотреть в спецификации RFC7231. По сути, безопасными считаются методы,
// которые обычно используются для чтения, но не для записи данных. Они не должны выполнять никаких операций на изменение данных.
// Переход по ссылке является всегда GET - методом, то есть безопасным.

// 2. Операция осуществляет навигацию верхнего уровня (изменяет URL в адресной строке браузера).
// Обычно это так, но если навигация выполняется в <iframe>, то это не верхний уровень.
// Кроме того, JavaScript - методы для сетевых запросов не выполняют никакой навигации, поэтому они не подходят.

// Но у неё есть важный недостаток:
// samesite игнорируется (не поддерживается) старыми браузерами, выпущенными до 2017 года и ранее.

// Лучше использовать это с другими вариантами защиты

// httpOnly
// Нельзя поставить через JS, ставится сервером.
// Запрещает читать и записывать такое куки

// Для работы с куками есть немало библиотек
