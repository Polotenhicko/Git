// Браузер позволяет отслеживать загрузку сторонних ресурсов: скриптов, ифреймов, изображений и др.

// Для этого существуют два события:

// load – успешная загрузка,
// error – во время загрузки произошла ошибка.

// Допустим, нам нужно загрузить сторонний скрипт и вызвать функцию, которая объявлена в этом скрипте.
// Мы загружаем его динамически

let script = document.createElement('script');
script.src = 'my.js';

document.head.append(script);

// уже был пример в промисах с onload
// событие load. Оно срабатывает после того, как скрипт был загружен и выполнен.
script.onload = function () {
  console.log(_);
};

// Что если ошибка?

// Можно отследить через onerror

// Запрашиваем несуществующий скрипт

script = document.createElement('script');
script.src = 'https://example.com/404.js';
document.head.append(script);

script.onerror = function () {
  console.error('Ошибка: ', this.src);
};

// Обработчики onload/onerror отслеживают только сам процесс загрузки.
// Мы не можем узнать какая ошибка была, 404 или 500
// Ещё onerror не вызовется если там будет ошибка внутри скрипты
// Чтобы обработать такую ошибку, нужно использовать window.onerror

window.onerror = function () {
  console.log('Ошибка window'); // сработало, но также есть ещё и Uncaught Error
};

// События load и error срабатывают для любых ресурсов с атрибутом src

let img = document.createElement('img');
img.src = 'https://js.cx/clipart/train.gif'; // (*)
// document.body.append(img);

img.onload = function () {
  console.log(`Изображение загружено, размеры ${img.width}x${img.height}`);
};

img.onerror = function () {
  console.log('Ошибка во время загрузки изображения');
};

// Особенности:
// 1. ресурсы загружаются после добавления на страницу. Но за исключением <img>, он сразу после получения src
// 2. для iframe событие load сработает при ошибке и просто успешной загрузке
// Почему? По качану

// Ошибка в скрипте с другого источника
// один источник (домен/порт/протокол) не может получить доступ к содержимому с другого источника

// Если мы используем скрипт с другого домена, и в нем имеется ошибка, мы не сможем узнать детали этой ошибки.

// Возьмём скрипт error.js, который состоит из одного вызова функции, которой нет

script = document.createElement('script');
script.src = 'error.js';
document.head.append(script);

window.onerror = function (message, url, line, col, errorObj) {
  console.log(`Ошибка: ${message}\n${url}, ${line}:${col}`);
};

// Ошибка: Uncaught ReferenceError: noSuchFunction is not defined
// http://127.0.0.1:5500/task2/Learn_JS_5/Learn_JS_5_3/error.js, 1:1
// и
// Uncaught ReferenceError: noSuchFunction is not defined

// Нормальный отчёт

// А теперь скрипт с другого домена

script = document.createElement('script');
script.src = 'https://cors.javascript.info/article/onload-onerror/crossorigin/error.js';
document.head.append(script);

// Ошибка: Script error.
// , 0:0

// Чёт не понятно что вывелось
// Детали отчёта могут варьироваться в зависимости от браузера, но основная идея остаётся неизменной:
//  любая информация о внутреннем устройстве скрипта, включая стек ошибки, спрятана.
// Именно потому, что скрипт загружен с другого домена.

// Зачем нам могут быть нужны детали ошибки?
// Существует много сервисов (и мы можем сделать наш собственный), которые обрабатывают глобальные ошибки при помощи window.onerror,
//  сохраняют отчёт о них и предоставляют доступ к этому отчёту для анализа
// Но если скрипт – с другого домена, то информации об ошибках в нём почти нет, как мы только что видели.

// Похожая кросс-доменная политика (CORS) внедрена и в отношении других ресурсов.

// !!!!!
// Чтобы разрешить кросс-доменный доступ, нам нужно поставить тегу <script> атрибут crossorigin, и,
//  кроме того, удалённый сервер должен поставить специальные заголовки.

// Существует три уровня кросс-доменного доступа:

// 1. Атрибут crossorigin отсутствует – доступ запрещён.
// 2. crossorigin="anonymous" – доступ разрешён, если сервер отвечает с заголовком Access-Control-Allow-Origin
//  со значениями * или наш домен.Браузер не отправляет авторизационную информацию и куки на удалённый сервер.
// 3. crossorigin="use-credentials" – доступ разрешён, если сервер отвечает с заголовками Access-Control-Allow-Origin
//  со значением наш домен и Access - Control - Allow - Credentials: true.Браузер отправляет авторизационную информацию
//  и куки на удалённый сервер.

// В нашем случае атрибут crossorigin отсутствовал. Поэтому кросс-доменный доступ был запрещён. Давайте добавим его.

// Мы можем выбрать "anonymous" (куки не отправляются, требуется один серверный заголовок)
// или "use-credentials"(куки отправляются, требуются два серверных заголовка) в качестве значения атрибута.

// Если куки нас не волнуют, тогда смело выбираем "anonymous":
script = document.createElement('script');
script.src = 'https://cors.javascript.info/article/onload-onerror/crossorigin/error.js';
script.crossOrigin = 'anonymous';
document.head.append(script);

// Теперь при условии, что сервер предоставил заголовок Access-Control-Allow-Origin, всё хорошо. У нас есть полный отчёт по ошибкам.
