// У жизненного цикла HTML-страницы есть три важных события:

// DOMContentLoaded - браузер полностью загрузил HTML, было построено DOM-дерево,, но внешние ресурсы(img, стили) могут быть ещё не загружены
// кроме script src=""
// load - браузер загрузил HTML и внешние ресурсы
// beforeunload/unload - пользователь покидает страницу

// Каждое из этих событий может быть полезно:

// Событие DOMContentLoaded – DOM готов, так что обработчик может искать DOM-узлы и инициализировать интерфейс.
// Событие load – внешние ресурсы были загружены, стили применены, размеры картинок известны и т.д.
// Событие beforeunload – пользователь покидает страницу.
// Мы можем проверить, сохранил ли он изменения и спросить, на самом ли деле он хочет уйти.
// unload – пользователь почти ушёл, но мы всё ещё можем запустить некоторые операции, например, отправить статистику.

// DOMContentLoaded
// оно срабатывает на объекте document
// Мы должны использовать addEventListener, чтобы поймать его:

document.addEventListener('DOMContentLoaded', function () {
  console.log('ready', img.offsetHeight, Date.now() - now); // ready 0 т.к. внешние источники ещё не загрузились
});

// На первый взгляд событие DOMContentLoaded очень простое.
// DOM - дерево готово – получаем событие.Хотя тут есть несколько особенностей.

// но если браузер встречает script когда строит DOM
// то сначала выполняется скрипт, а потом строится дерево дальше
// вдруг мы захотим поменять DOM, или переписатьего (document.write)

// есть исключения
// 1. Скрипт с тегом async, он не заставляет DOMContentLoaded ждать
// 2. Скрипты, сгенерированные динамически при помощи document.createElement('script') и затем добавленные на сайт
// второй не понятно почему

// внешние таблицы стилей не затрагивают DOM
// но есть подводный камень
// Если после стилей есть скрипт, то скрипт должен дождаться  пока подгрузятся стили

// У браузеров ест встроенное автозаполнение
// оно наступает после DOMCOntentLoaded

// Например, если на странице есть форма логина и пароля и браузер запомнил значения, то при наступлении DOMContentLoaded
// он попытается заполнить их(если получил разрешение от пользователя).
// Так что если будет небольшое ожидание до DOMContentLoaded, то и форма не будет сразу заполнена, а через время

// window.onload
// срабатывает на window когда вся страница, включая стили, картинки и др. ресурсы загрузились
// доступно через onload

window.onload = function () {
  console.log('onload', img.offsetHeight);
};

// window.onunload
// Когда посетитель покидает страницу, на объекте window генерируется событие unload
// Советуют совершать простые действия, не требующие много времени, типа закрытия всплывающих окон
// Можно отослать сатистику
// unload – это тот момент, когда пользователь нас покидает и мы хотим сохранить эти данные.
// Для этого существует специальный метод navigator.sendBeacon(url, data)
// Он посылает данные в фоне. Переход к другой странице не задерживается: браузер покидает страницу, но всё равно выполняет sendBeacon.
let analyticsData = {
  test: 'aboba',
};

window.addEventListener('unload', function () {
  navigator.sendBeacon('/analytics', JSON.stringify(analyticsData));
});

// Отсылается POST-запрос.
// Мы можем послать не только строку, но так же формы и другие форматы, как описано в главе Fetch, но обычно это строковый объект.
// Размер данных ограничен 64 Кб.

// Для таких запросов с закрывающейся страницей есть специальный флаг keepalive в методе fetch для общих сетевых запросов
// Если мы хотим отменить переход на другую страницу, то здесь мы этого сделать не сможем. Но сможем в другом месте – в событии onbeforeunload.

// window.onbeforeunload
// Если посетитель собирается уйти со страницы или закрыть окно, обработчик beforeunload попросит дополнительное подтверждение.
// Если мы отменим это событие, то браузер спросит посетителя, уверен ли он.

window.onbeforeunload = function () {
  return false; // можно и пустую строку
};

// Когда-то браузеры использовали её в качестве сообщения, но, как указывает современная спецификация, они не должны этого делать.

window.onbeforeunload = function () {
  return 'Текст'; // не сработает
};

window.onbeforeunload = function () {
  return false;
};

// readyState
// Если мы установим DOMContentLoaded после того, как документ загрузится, то естественно это событие не запустится

// Мы можем быть не уверены, готов документ или нет
// Хотим чтобы функция запустилась когда DOM загрузится, сейчас, или позже

// Есть свойство document.readyState показывает наше текущее состояние загрузки

// Есть три возможных значения:

// "loading" – документ загружается.
// "interactive" – документ был полностью прочитан.
// "complete" – документ был полностью прочитан и все ресурсы (такие как изображения) были тоже загружены.

// Пример

function work() {
  console.log('Выполняй');
}
console.log(document.readyState);
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', work);
} else {
  work();
}

// Ещё есть событие readystatechange
// генерируется при изменении состояния
// Легаси, используется редко

document.addEventListener('readystatechange', () => console.log('Поменялся', document.readyState));
