// у разных узлов разные свойства
// но есть общие

// Каждый DOM-узел принадлежит соответствующему встроенному классу.

// Корнем иерархии является EventTarget, от него наследует Node и остальные DOM-узлы.

// Существуют следующие классы:

// EventTarget – это корневой «абстрактный» класс для всего.
// Объекты этого класса никогда не создаются. Он служит основой, благодаря которой
//  все DOM - узлы поддерживают так называемые «события», о которых мы поговорим позже.

// Node – также является «абстрактным» классом, и служит основой для DOM-узлов.
// Он обеспечивает базовую функциональность: parentNode, nextSibling, childNodes и т.д. (это геттеры).
// Объекты класса Node никогда не создаются.Но есть определённые классы узлов,
// которые наследуются от него(и следовательно наследуют функционал Node).

// Document, по историческим причинам часто наследуется HTMLDocument
// (хотя последняя спецификация этого не навязывает) – это документ в целом.
// Глобальный объект document принадлежит именно к этому классу. Он служит точкой входа в DOM.

// CharacterData – «абстрактный» класс. Вот, кем он наследуется:
// Text – класс, соответствующий тексту внутри элементов. Например, Hello в <p>Hello</p>.
// Comment – класс для комментариев. Они не отображаются, но каждый комментарий становится членом DOM.

// Element – это базовый класс для DOM-элементов.
// Он обеспечивает навигацию на уровне элементов: nextElementSibling, children.
// А также и методы поиска элементов: getElementsByTagName, querySelector.

// Браузер поддерживает не только HTML, но также XML и SVG. Таким образом,
// класс Element служит основой для более специфичных классов:
// SVGElement, XmlElement(они нам здесь не нужны) и HTMLElement.

// И наконец, HTMLElement является базовым классом для всех остальных HTML-элементов.
// От него наследуются конкретные элементы:
// HTMLInputElement – класс для тега <input>,
// HTMLBodyElement – класс для тега <body>,
// HTMLAnchorElement – класс для тега <a>,
// …и т.д.

// Также существует множество других тегов со своими собственными классами,
// которые могут иметь определенные свойства и методы, в то время как некоторые элементы,
// такие как < span >, <section> и <article>, не имеют каких-либо определенных свойств,
// поэтому они являются экземплярами класса HTMLElement.

// Рассмотрим DOM-объект для тега <input>. Он принадлежит классу HTMLInputElement.

// Он получает свойства и методы из (в порядке наследования):

// HTMLInputElement – этот класс предоставляет специфичные для элементов формы свойства,
// HTMLElement – предоставляет общие для HTML-элементов методы (и геттеры/сеттеры),
// Element – предоставляет типовые методы элемента,
// Node – предоставляет общие свойства DOM-узлов,
// EventTarget – обеспечивает поддержку событий (поговорим о них дальше),
// …и, наконец, он наследует от Object, поэтому доступны также методы «обычного объекта»,
// такие как hasOwnProperty.

// Проверить наследование можно также при помощи instanceof:

console.log(document.body instanceof HTMLBodyElement); // true
console.log(document.body instanceof HTMLElement); // true
console.log(document.body instanceof Element); // true
console.log(document.body instanceof Node); // true
console.log(document.body instanceof EventTarget); // true

console.log('-----------');

// console.dir(elem) и console.log(elem)
// Для JavaScript-объектов эти команды обычно выводят одно и то же.

// Но для DOM-элементов они работают по-разному:

// console.log(elem) выводит элемент в виде DOM-дерева.
// console.dir(elem) выводит элемент в виде DOM-объекта, что удобно для анализа его свойств.

console.log(document.body);
console.dir(document.body);

// В спецификации для описания классов DOM используется не JavaScript,
// а специальный язык Interface description language(IDL), с которым достаточно легко разобраться.

// Свойство nodeType предоставляет ещё один, «старомодный» способ узнать «тип» DOM-узла.

// Его значением является цифра:

// elem.nodeType == 1 для узлов-элементов,
// elem.nodeType == 3 для текстовых узлов,
// elem.nodeType == 9 для объектов документа,

console.log(document.body.nodeType); // 1

// Получив DOM-узел, мы можем узнать имя его тега из свойств nodeName и tagName:

console.log(document.body.nodeName); // "BODY"
console.log(document.body.tagName); // "BODY"

// разница отражена в названиях свойств, но не очевидна.

// Свойство tagName есть только у элементов Element.
// Свойство nodeName определено для любых узлов Node:
// для элементов оно равно tagName.
// для остальных типов узлов (текст, комментарий и т.д.) оно содержит строку с типом узла.

console.log(document.body.firstChild.tagName); // undefined
console.log(document.body.firstChild.nodeName); // #text

// Имена тегов (кроме XHTML) всегда пишутся в верхнем регистре
// В XML-режиме регистр сохраняется «как есть». В настоящее время XML-режим применяется редко.

// Свойство innerHTML позволяет получить HTML-содержимое элемента в виде строки.
// Мы также можем изменять его
console.log(document.body.innerHTML);
// <h1>Абоба</h1>
// <script src="./index.js"></script>

// Если innerHTML вставляет в документ тег <script> – он становится частью HTML, но не запускается.

// Мы можем добавить HTML к элементу, используя elem.innerHTML+="ещё html".
// Так как содержимое «обнуляется» и переписывается заново, все изображения
// и другие ресурсы будут перезагружены.

// Другими словами, innerHTML+= делает следующее:

// Старое содержимое удаляется.
// На его место становится новое значение innerHTML (с добавленной строкой).

// Свойство outerHTML содержит HTML элемента целиком. Это как innerHTML плюс сам элемент.

// <h2><p>Абоба2</p></h2>
console.log(document.querySelector('h2').outerHTML);

// в отличие от innerHTML, запись в outerHTML не изменяет элемент.
// Вместо этого элемент заменяется целиком во внешнем контексте.

const h2 = document.querySelector('h2');
h2.outerHTML = '<p>Новый элемент</p>';
console.log(h2.outerHTML); // <h2><p>Абоба2</p></h2> тоже самое!

// Это потому, что использование outerHTML не изменяет DOM-элемент,
// а удаляет его из внешнего контекста и вставляет вместо него новый HTML - код.

// Здесь легко сделать ошибку: заменить div.outerHTML, а потом продолжить работать с div,
//  как будто там новое содержимое.Но это не так.Подобное верно для innerHTML, но не для outerHTML.

// Свойство innerHTML есть только у узлов-элементов.

// У других типов узлов, в частности, у текстовых, есть свои аналоги: свойства nodeValue и data.
// Эти свойства очень похожи при использовании, есть лишь небольшие различия в спецификации

console.log(document.body.firstChild.nextSibling.data); // "коммент"

// Иногда их используют для вставки информации и инструкций шаблонизатора в HTML, как в примере ниже:

// <!-- if isAdmin -->
//   <div>Добро пожаловать, Admin!</div>
// <!-- /if -->

// Свойство textContent предоставляет доступ к тексту внутри элемента за вычетом всех <тегов>.
console.log(document.body.textContent);
//  Абоба
//     Новый элемент
// возвращается только текст, как если бы все <теги> были вырезаны, но текст в них остался.
// Намного полезнее возможность записывать текст в textContent,
// т.к.позволяет писать текст «безопасным способом».

// Представим, что у нас есть произвольная строка, введённая пользователем, и мы хотим показать её.

// С innerHTML вставка происходит «как HTML», со всеми HTML-тегами.
// С textContent вставка получается «как текст», все символы трактуются буквально.

// Мы не хотим, чтобы на сайте появлялся произвольный HTML-код.
// Присваивание через textContent – один из способов от этого защититься.

// Атрибут и DOM-свойство «hidden» указывает на то, видим ли мы элемент или нет.
// Мы можем использовать его в HTML или назначать при помощи JavaScript, как в примере ниже:

document.querySelector('h1').hidden = true;

// У DOM-элементов есть дополнительные свойства, в частности, зависящие от класса:

// value – значение для <input>, <select> и <textarea> (HTMLInputElement, HTMLSelectElement…).
// href – адрес ссылки «href» для <a href="..."> (HTMLAnchorElement).
// id – значение атрибута «id» для всех элементов (HTMLElement).
// …и многие другие…

const id = document.getElementById('input');
console.log(id.value); // 123
console.log(id.type); // text
console.log(id.id); // input
