// Многие события автоматически влекут за собой действие браузера.

// Например:

// Клик по ссылке инициирует переход на новый URL.
// Нажатие на кнопку «отправить» в форме – отсылку её на сервер.
// Зажатие кнопки мыши над текстом и её движение в таком состоянии – инициирует его выделение.

// Если мы обрабатываем событие в JavaScript, то зачастую такое действие браузера нам не нужно. К счастью, его можно отменить.

// Есть два способа отменить действие браузера:

// Основной способ – это воспользоваться объектом event.
// Для отмены действия браузера существует стандартный метод event.preventDefault().

// Если же обработчик назначен через on<событие> (не через addEventListener), то также можно вернуть false из обработчика.

document.getElementById('a1').addEventListener('click', function (e) {
  e.preventDefault(); // теперь не переходит по ссылке
});

document.getElementById('a2').addEventListener('click', function (e) {
  return false; // не сработает
  // нужно чтобы было onclick="return false"
});

// Обычно значение, которое возвращает обработчик события, игнорируется.

// В HTML-разметке все элементы меню являются не кнопками, а ссылками, то есть тегами <a>.
// В этом подходе есть некоторые преимущества, например:

// Некоторые посетители очень любят сочетание «правый клик – открыть в новом окне».
// Если мы будем использовать < button > или < span >, то данное сочетание работать не будет.

// Поисковые движки переходят по ссылкам <a href="..."> при индексации.

// необходимо обрабатывать клики в JavaScript, а стандартное действие браузера (переход по ссылке) – отменить.

const menu = document.getElementById('menu');

menu.addEventListener('click', function (e) {
  if (e.target.nodeName != 'A') return;
  const href = e.target.getAttribute('href');
  console.log(href);
  e.preventDefault();
});

// Кстати, использование здесь делегирования событий делает наше меню очень гибким.
// Мы можем добавить вложенные списки и стилизовать их с помощью CSS – обработчик не потребует изменений.

// Некоторые события естественным образом вытекают друг из друга. Если мы отменим первое событие, то последующие не возникнут.

// Например, событие mousedown для поля <input> приводит к фокусировке на нём и запускает событие focus.
// Если мы отменим событие mousedown, то фокусирования не произойдёт.

// Необязательная опция passive: true для addEventListener сигнализирует браузеру,
// что обработчик не собирается выполнять preventDefault().
// Почему это может быть полезно?

// Есть некоторые события, как touchmove на мобильных устройствах (когда пользователь перемещает палец по экрану),
// которое по умолчанию начинает прокрутку, но мы можем отменить это действие, используя preventDefault() в обработчике.

// Поэтому, когда браузер обнаружит такое событие, он должен для начала запустить все обработчики и после,
//  если preventDefault не вызывается нигде, он может начать прокрутку.
// Это может вызвать ненужные задержки в пользовательском интерфейсе.

// Опция passive: true сообщает браузеру, что обработчик не собирается отменять прокрутку.
// Тогда браузер начинает её немедленно, обеспечивая максимально плавный интерфейс, параллельно обрабатывая событие.

// Для некоторых браузеров (Firefox, Chrome) опция passive по умолчанию включена в true для таких событий, как touchstart и touchmove.

// event.defaultPrevented
// Свойство event.defaultPrevented установлено в true, если действие по умолчанию было предотвращено, и false, если нет.

// По умолчанию браузер при событии contextmenu (клик правой кнопкой мыши) показывает контекстное меню со стандартными опциями.
// Мы можем отменить событие по умолчанию и показать своё меню

const button = document.getElementById('button');
// button.addEventListener('contextmenu', function (e) {
//   e.preventDefault();
//   e.stopPropagation(); // чтобы не вызывать контекст документа
//   alert('Контекстное меню');
// });

// Теперь в дополнение к этому контекстному меню реализуем контекстное меню для всего документа.

// document.addEventListener('contextmenu', function (e) {
//   e.preventDefault();
//   alert('Контекст документа');
// });

// Мы навсегда запретили доступ к информации о правых кликах для любого внешнего кода, включая счётчики,
// которые могли бы собирать статистику, и т.п.Это слегка неразумно.

// Альтернативным решением было бы проверить в обработчике document, было ли отменено действие по умолчанию?
// Если да, тогда событие было обработано, и нам не нужно на него реагировать.

button.addEventListener('contextmenu', function (e) {
  e.preventDefault();
  alert('Контекстное меню');
});

document.addEventListener('contextmenu', function (e) {
  if (e.defaultPrevented) return;
  e.preventDefault();
  alert('Контекст документа');
});

// Сейчас всё работает правильно.
// Если у нас есть вложенные элементы и каждый из них имеет контекстное меню, то код также будет работать

// Есть также несколько альтернативных путей, чтобы реализовать вложенные контекстные меню
// Одним из них является единый глобальный объект с обработчиком document.oncontextmenu и методами, позволяющими хранить в нём другие обработчики.
