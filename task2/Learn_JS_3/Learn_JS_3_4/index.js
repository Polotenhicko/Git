// на современных устройствах есть и другие способы «ввести что-то»
// Например, распознавание речи (это особенно актуально на мобильных устройствах) или Копировать/Вставить с помощью мыши.

// Поэтому, если мы хотим корректно отслеживать ввод в поле <input>, то одних клавиатурных событий недостаточно.
// Существует специальное событие input, чтобы отслеживать любые изменения в поле < input >

// События клавиатуры же должны использоваться, если мы хотим обрабатывать взаимодействие пользователя именно с клавиатурой
// (в том числе виртуальной)

// Событие keydown происходит при нажатии клавиши, а keyup – при отпускании.

// event.code и event.key

// К примеру, одну и ту же клавишу Z можно нажать с клавишей Shift и без неё.
// В результате получится два разных символа: z в нижнем регистре и Z в верхнем регистре.

// Клавиша	  event.key	            event.code
// Z	        z (нижний регистр)	  KeyZ
// Shift+Z	  Z (Верхний регистр)	  KeyZ

// У каждой клавиши есть код, который зависит от её расположения на клавиатуре
// Например:

// Буквенные клавиши имеют коды по типу "Key<буква>": "KeyA", "KeyB" и т.д.
// Коды числовых клавиш строятся по принципу: "Digit<число>": "Digit0", "Digit1" и т.д.
// Код специальных клавиш – это их имя: "Enter", "Backspace", "Tab" и т.д.

// Регистр важен: "KeyZ", а не "keyZ"

// если клавиша не буквенно-цифровая, например Shift или F1

// Клавиша	        event.key	    event.code
// F1	              F1	          F1
// Backspace	      Backspace	    Backspace
// Shift	          Shift	        ShiftRight или ShiftLeft

// Обратите внимание, что event.code точно указывает, какая именно клавиша нажата

// Допустим, мы хотим обработать горячую клавишу Ctrl+Z (или Cmd+Z для Mac).
// Большинство текстовых редакторов к этой комбинации подключают действие «Отменить».
// Мы можем поставить обработчик событий на keydown и проверять, какая клавиша была нажата.

// имеет смысл проверять event.code, ведь его значение всегда одно и тоже.

document.addEventListener('keydown', function (e) {
  console.log(e.repeat);
  if (e.code == 'KeyZ' && (e.ctrlKey || e.metaKey)) {
    console.log('Отмена');
  }
});

// С другой стороны, с event.code тоже есть проблемы. На разных раскладках к одной и той же клавише могут быть привязаны разные символы.
// к примеру, английская и немецкая клавиатура, у них разные раскладки

// Буквально, для пользователей с немецкой раскладкой event.code при нажатии на Y будет равен KeyZ.
// Если мы будем проверять в нашем коде event.code == 'KeyZ', то для людей с немецкой раскладкой такая проверка сработает, когда они нажимают Y.

// К счастью, это происходит не со всеми кодами, а с несколькими, например KeyA, KeyQ, KeyZ (как мы уже видели), и не происходит со специальными клавишами, такими как Shift

// Чтобы отслеживать символы, зависящие от раскладки, event.key надёжнее.

// С другой стороны, преимущество event.code заключается в том, что его значение всегда остаётся неизменным, будучи привязанным к физическому местоположению клавиши, даже если пользователь меняет язык

// Хотим поддерживать клавиши, меняющиеся при раскладке? Тогда event.key – верный выбор.

// Или мы хотим, чтобы горячая клавиша срабатывала даже после переключения на другой язык? Тогда event.code может быть лучше.

// При долгом нажатии клавиши возникает автоповтор: keydown срабатывает снова и снова, и когда клавишу отпускают,
// то отрабатывает keyup.Так что ситуация, когда много keydownи один keyup, абсолютно нормальна.

// Для событий, вызванных автоповтором, у объекта события свойство event.repeat равно true.

// Действия по умолчанию весьма разнообразны, много чего можно инициировать нажатием на клавиатуре.
// Для примера:

// Появление символа (самое очевидное).
// Удаление символа (клавиша Delete).
// Прокрутка страницы (клавиша PageDown).
// Открытие диалогового окна браузера «Сохранить» (Ctrl+S)
// …и так далее.

// Предотвращение стандартного действия с помощью event.preventDefault() работает практически во всех сценариях,
// кроме тех, которые происходят на уровне операционной системы.Например, комбинация Alt + F4 инициирует закрытие браузера в Windows,
//  что бы мы ни делали в JavaScript.

input.onkeydown = function (e) {
  const key = e.key;
  return (
    (key >= '0' && key <= '9') ||
    key == '+' ||
    key == '(' ||
    key == ')' ||
    key == '-' ||
    key == 'ArrowLeft' ||
    key == 'ArrowRight' ||
    key == 'Delete' ||
    key == 'Backspace'
  );
};

// Заметьте, что специальные клавиши, такие как Backspace, Left, Right, Ctrl+V, в этом поле для ввода не работают.
// Это побочный эффект чересчур жёсткого фильтра.

// исправим

input.onkeydown = function (e) {
  const key = e.key;
  return (
    (key >= '0' && key <= '9') ||
    key == '+' ||
    key == '(' ||
    key == ')' ||
    key == '-' ||
    key == 'ArrowLeft' ||
    key == 'ArrowRight' ||
    key == 'Delete' ||
    key == 'Backspace'
  );
};

// Впрочем, мы всё равно можем ввести в <input> что угодно с помощью правого клика мыши и пункта «Вставить» контекстного меню
// Так что такой фильтр не обладает 100% надёжностью

// Альтернатива – отслеживать событие input, оно генерируется после любых изменений в поле <input>
// и мы можем проверять новое значение и подчёркивать/изменять его, если оно не подходит.

// В прошлом существовало также событие keypress, а также свойства keyCode, charCode, which у объекта события.

// Старый код ещё работает, так как браузеры продолжают поддерживать и keypress, и keyCode с charCode, и which, но более нет никакой необходимости в их использовании.

// Нажатие клавиши всегда генерирует клавиатурное событие, будь то буквенно-цифровая клавиша или специальная типа Shift или Ctrl и т.д.
//  Единственным исключением является клавиша Fn, которая присутствует на клавиатуре некоторых ноутбуков
