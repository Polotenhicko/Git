// Событие mouseover происходит в момент, когда курсор оказывается над элементом,
//  а событие mouseout – в момент, когда курсор уходит с элемента.

// Эти события являются особенными, потому что у них имеется свойство relatedTarget

// Оно «дополняет» target. Когда мышь переходит с одного элемента на другой,
// то один из них будет target, а другой relatedTarget.

// Для события mouseover:
// e.target - элемент, на который курсор перешёл
// e.relatedTarget - элемент, с которого ушёл курсор (relatedTarget - target)

// Для событий mouseout наоборот
// e.target - элемент, с которого курсор ушёл
// e.relatedTarget - элемент, на который перешли (target - relatedTarget)

// Свойство relatedTarget может быть null
// Это нормально и означает, что указатель мыши перешёл не с другого элемента, а из-за пределов окна браузера.
// Или же, наоборот, ушёл за пределы окна.

// Можно проебаться и когда relatedTarget будет null, то попытаться вызвать null.tagName

// Событие mousemove происходит при движении мыши.
// Однако, это не означает, что указанное событие генерируется при прохождении каждого пикселя.

// Это означает, что если пользователь двигает мышкой очень быстро, то некоторые DOM-элементы могут быть пропущены

// Это хорошо с точки зрения производительности, потому что если промежуточных элементов много,
// вряд ли мы действительно хотим обрабатывать вход и выход для каждого.

// С другой стороны, мы должны иметь в виду, что указатель мыши не «посещает» все элементы на своём пути. Он может и «прыгать».

// Несмотря на то, что при быстрых переходах промежуточные элементы могут игнорироваться,
// в одном мы можем быть уверены: элемент может быть пропущен только целиком.
// Если был mouseover, то будет и mouseout

// Важная особенность события mouseout – оно генерируется в том числе, когда указатель переходит с элемента на его потомка.
// То есть, визуально указатель всё ещё на элементе, но мы получим mouseout!

// По логике браузера, курсор мыши может быть только над одним элементом в любой момент времени
// – над самым глубоко вложенным и верхним по z - index.

// Таким образом, если курсор переходит на другой элемент (пусть даже дочерний), то он покидает предыдущий

// !!!!!
// Событие mouseover, происходящее на потомке, всплывает.
// Поэтому если на родительском элементе есть такой обработчик, то оно его вызовет.

document.onmouseout = function (e) {
  console.log('out на document!', 'related: ' + e.relatedTarget?.nodeName, 'target: ' + e.target?.nodeName);
};

// хоть и обработчик на документе, но при переходе с дива на див - случается событие, т.к. всплытие
// то есть срабатывает mouseover/out, но на самом деле это всё внутри элемента и никуда курсор мог не выйти

// Чтобы этого избежать, можно смотреть на relatedTarget и, если мышь всё ещё внутри элемента, то игнорировать такие события.

// Или же можно использовать другие события: mouseenter и mouseleave, с ними такая проблема не возникает.

// События mouseenter/mouseleave похожи на mouseover/mouseout

// Но есть и пара важных отличий:

// Переходы внутри элемента, на его потомки и с них, не считаются.
// События mouseenter/mouseleave не всплывают.

// Когда указатель появляется над элементом – генерируется mouseenter,
// причём не имеет значения, где именно указатель: на самом элементе или на его потомке.

// Событие mouseleave происходит, когда курсор покидает элемент.

// по сути это единственные различия

// События mouseenter/leave просты и легки в использовании. Но они не всплывают. Таким образом, мы не можем их делегировать.

// мы хотим обрабатывать события, сгенерированные при движении курсора по ячейкам таблицы. И в таблице сотни ячеек.
// лучше подойдёт mouseover/out

document.onmouseout = null;

table.onmouseover = function (e) {
  e.target.style.background = 'pink';
};

table.onmouseout = function (e) {
  e.target.style.background = '';
};

// В нашем случае мы хотим обрабатывать переходы именно между ячейками <td>: вход на ячейку и выход с неё.
// Прочие переходы, в частности, внутри ячейки < td > или вообще вне любых ячеек, нас не интересуют, хорошо бы их отфильтровать.

let currentTd;

table.onmouseover = function (e) {
  if (currentTd) return; // уже сет прошёл
  const target = e.target.closest('td');
  if (!target) return; // это не td
  if (!table.contains(target)) return; // проверка что именно в нашей таблице, ведь событие всплывает
  currentTd = target;
  target.style.background = 'pink';
};

table.onmouseout = function (e) {
  if (!currentTd) return;
  if (currentTd.contains(e.relatedTarget)) return; // проверка что это переход не внутри currentTd
  currentTd.style.background = '';
  currentTd = null;
};
